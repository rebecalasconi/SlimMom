{"ast":null,"code":"const express = require('express');\nconst Joi = require('joi');\nconst bcrypt = require('bcryptjs');\nconst multer = require('multer');\nconst sharp = require('sharp'); // Importăm Sharp\nconst fs = require('fs');\nconst path = require('path');\nconst gravatar = require('gravatar');\nconst User = require('../models/Users');\nconst auth = require('../middleware/auth');\nrequire('dotenv').config();\nconst sgMail = require('@sendgrid/mail');\nsgMail.setApiKey(process.env.SENDGRID_API_KEY);\nconsole.log(process.env.SENDGRID_API_KEY);\nconst router = express.Router();\nconst userSchema = Joi.object({\n  email: Joi.string().email().required(),\n  password: Joi.string().min(6).required()\n});\n\n// Configurare pentru stocare pe disc\nconst storage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    const uploadPath = path.join(__dirname, '..', 'tmp');\n    if (!fs.existsSync(uploadPath)) {\n      fs.mkdirSync(uploadPath, {\n        recursive: true\n      });\n    }\n    cb(null, uploadPath);\n  },\n  filename: (req, file, cb) => {\n    const uniqueName = `${Date.now()}-${file.originalname}`;\n    cb(null, uniqueName);\n  }\n});\nconst upload = multer({\n  storage: storage\n});\n\n// Endpoint pentru înregistrare utilizator\n// router.post('/signup', async (req, res) => {\n//   const { error } = userSchema.validate(req.body);\n//   if (error) return res.status(400).json({ message: error.details[0].message });\n\n//   const { email, password } = req.body;\n//   const existingUser = await User.findOne({ email });\n//   if (existingUser) return res.status(409).json({ message: 'Email in use' });\n\n//   const user = new User({ email, password });\n\n//   // Generăm avatar cu Gravatar\n//   const avatarURL = gravatar.url(user.email, { s: '250', r: 'x', d: 'identicon' });\n//   user.avatarURL = avatarURL;\n\n//   try {\n//     await user.save();\n//     const token = user.generateAuthToken();\n//     user.token = token; \n//     await user.save();\n\n//     res.status(201).json({\n//       user: {\n//         email: user.email,\n//         subscription: user.subscription,\n//         avatarURL: user.avatarURL,\n//       },\n//       token,\n//     });\n//   } catch (error) {\n//     return res.status(500).json({ message: 'Error saving user with token', error });\n//   }\n// });\nconst {\n  v4: uuidv4\n} = require('uuid'); // Importăm uuid pentru a genera un token aleator\n\nrouter.post('/signup', async (req, res) => {\n  const {\n    error\n  } = userSchema.validate(req.body);\n  if (error) return res.status(400).json({\n    message: error.details[0].message\n  });\n  const {\n    email,\n    password\n  } = req.body;\n  const existingUser = await User.findOne({\n    email\n  });\n  if (existingUser) return res.status(409).json({\n    message: 'Email in use'\n  });\n  const verificationToken = uuidv4(); // Generăm un token unic de verificare pentru utilizator\n\n  const user = new User({\n    email,\n    password,\n    verificationToken // Setăm token-ul de verificare\n  });\n\n  // Generăm avatar cu Gravatar\n  const avatarURL = gravatar.url(user.email, {\n    s: '250',\n    r: 'x',\n    d: 'identicon'\n  });\n  user.avatarURL = avatarURL;\n  try {\n    await user.save();\n    const token = user.generateAuthToken();\n    user.token = token;\n    await user.save();\n\n    // Trimite e-mail de verificare\n    const msg = {\n      from: 'rebecavoicilas@yahoo.com',\n      // Asigură-te că folosești o adresă validă\n      to: user.email,\n      subject: 'Please verify your email address',\n      text: `To verify your email address, click on the link below:\\n\\nhttp://localhost:3000/users/verify/${verificationToken}`,\n      html: `<p>To verify your email address, click on the link below:</p><a href=\"http://localhost:3000/users/verify/${verificationToken}\">Verify Email</a>`\n    };\n    sgMail.send(msg).then(() => {\n      console.log('Email sent');\n    }).catch(error => {\n      console.error('Error sending email:', error.response ? error.response.body : error);\n    });\n    res.status(201).json({\n      user: {\n        email: user.email,\n        subscription: user.subscription,\n        avatarURL: user.avatarURL\n      },\n      token,\n      verificationToken: user.verificationToken\n    });\n  } catch (error) {\n    return res.status(500).json({\n      message: 'Error saving user with token',\n      error\n    });\n  }\n});\n\n// Endpoint pentru login utilizator\nrouter.post('/login', async (req, res) => {\n  const {\n    email,\n    password\n  } = req.body;\n  const {\n    error\n  } = userSchema.validate(req.body);\n  if (error) return res.status(400).json({\n    message: error.details[0].message\n  });\n  const user = await User.findOne({\n    email\n  });\n  if (!user) return res.status(401).json({\n    message: 'Email or password is wrong'\n  });\n\n  // Verifică dacă utilizatorul este verificat\n  if (!user.verify) {\n    return res.status(400).json({\n      message: 'Email is not verified'\n    });\n  }\n  const isMatch = await bcrypt.compare(password, user.password);\n  if (!isMatch) return res.status(401).json({\n    message: 'Email or password is wrong'\n  });\n  const token = user.generateAuthToken();\n  user.token = token;\n  try {\n    await user.save();\n  } catch (error) {\n    return res.status(500).json({\n      message: 'Error saving user with token',\n      error\n    });\n  }\n  res.status(200).json({\n    token,\n    user: {\n      email: user.email,\n      subscription: user.subscription\n    }\n  });\n});\n\n// Endpoint pentru logout utilizator\nrouter.get('/logout', auth, async (req, res) => {\n  req.user.token = null;\n  await req.user.save();\n  res.status(204).send();\n});\n\n// // Endpoint pentru obținerea datelor utilizatorului curent\n// router.get('/current', auth, (req, res) => {\n//   res.status(200).json({\n//     email: req.user.email,\n//     subscription: req.user.subscription,\n//   });\n// });\n\n// // Endpoint pentru actualizarea avatarului\n// router.patch('/avatars', auth, upload.single('avatar'), async (req, res) => {\n//   try {\n//     const userId = req.user.id; // ID-ul utilizatorului este disponibil în req.user datorită middleware-ului auth\n//     const user = await User.findById(userId); // Căutăm utilizatorul în baza de date\n\n//     if (!req.file) {\n//       return res.status(400).json({ message: 'No file uploaded' });\n//     }\n\n//     if (!user) {\n//       return res.status(404).json({ message: 'User not found' });\n//     }\n\n//     // Calea fișierului temporar și calea finală\n//     const tempImagePath = path.join(__dirname, '..', 'tmp', req.file.filename);\n//     const avatarName = `${userId}-${Date.now()}.jpg`;\n//     const finalAvatarPath = path.join(__dirname, '..', 'public', 'avatars', avatarName);\n\n//     // Log pentru a verifica calea finală\n//     console.log('Temp Image Path:', tempImagePath);\n//     console.log('Final Avatar Path:', finalAvatarPath);\n\n//     // Verificăm dacă directorul 'avatars' există, dacă nu, îl creăm\n//     const avatarDir = path.dirname(finalAvatarPath);\n//     if (!fs.existsSync(avatarDir)) {\n//       fs.mkdirSync(avatarDir, { recursive: true });\n//       console.log('Created avatars directory:', avatarDir);  // Log pentru a confirma crearea directorului\n//     }\n\n//     // Folosim sharp pentru a redimensiona imaginea\n//     await sharp(tempImagePath)\n//       .resize(250, 250)\n//       .toFile(finalAvatarPath);  // Scriem fișierul procesat în folderul public/avatars\n\n//     // Actualizăm avatarURL-ul în baza de date\n//     user.avatarURL = `/avatars/${avatarName}`;\n//     await user.save(); // Salvăm utilizatorul cu noul avatar\n\n//     // Răspuns de succes cu URL-ul avatarului\n//     res.status(200).json({ avatarURL: user.avatarURL });\n\n//   } catch (error) {\n//     console.error(error);\n//     res.status(500).json({ message: 'Internal server error' });\n//     console.log('Request file:', req.file);\n//     console.log('Request body:', req.body);\n//     console.log('Request headers:', req.headers);\n//   }\n// });\n\n// router.get('/verify/:verificationToken', async (req, res) => {\n//   const { verificationToken } = req.params; // Extragem tokenul de verificare din URL\n//   console.log('Verification Token:', verificationToken);\n\n//   // Căutăm utilizatorul în baza de date care are acest token de verificare\n//   const user = await User.findOne({ verificationToken }); \n\n//   if (!user) {\n//     return res.status(404).json({ message: 'User not found' }); // Dacă nu găsim utilizatorul cu tokenul respectiv\n//   }\n\n//   if (user.verify) {\n//     return res.status(400).json({ message: 'Email is already verified' }); // Dacă utilizatorul a fost deja verificat\n//   }\n\n//   // Dacă utilizatorul a fost găsit și nu a fost încă verificat\n//   user.verify = true; // Setăm câmpul `verify` la `true` pentru a indica faptul că emailul a fost verificat\n//   user.verificationToken = null; // Ștergem tokenul de verificare, deoarece a fost utilizat\n//   await user.save(); // Salvăm modificările în baza de date\n//   console.log('User after verification:', user);\n\n//   res.status(200).json({ message: 'Verification successful' }); // Răspuns de succes\n// });\n\n// // Endpoint pentru trimiterea unui e-mail de verificare repetat\n// router.post('/verify', async (req, res) => {\n//   const { email } = req.body; // Extragem email-ul din request body\n\n//   if (!email) {\n//     return res.status(400).json({ message: 'missing required field email' }); // Verificăm dacă există câmpul email\n//   }\n\n//   const user = await User.findOne({ email }); // Căutăm utilizatorul cu acest email\n//   console.log('User found:', user);\n\n//   if (!user) {\n//     return res.status(404).json({ message: 'User not found' }); // Dacă utilizatorul nu există\n//   }\n\n//   if (user.verify) {\n//     return res.status(400).json({ message: 'Verification has already been passed' }); // Dacă utilizatorul este deja verificat\n//   }\n\n//   // Trimitem e-mail de verificare\n//   const msg = {\n//     to: user.email,\n//     from: 'rebecavoicilas@yahoo.com', // Adresa de e-mail de pe care se trimit mesajele\n//     subject: 'Please verify your email address',\n//     text: `To verify your email address, click on the link below:\\n\\nhttp://localhost:3000/users/verify/${user.verificationToken}`,\n//     html: `<p>To verify your email address, click on the link below:</p><a href=\"http://localhost:3000/users/verify/${user.verificationToken}\">Verify Email</a>`,\n//   };\n\n//   try {\n//     await sgMail.send(msg); // Trimiterea efectivă a e-mailului\n//     res.status(200).json({ message: 'Verification email sent' });\n//   } catch (error) {\n//     console.error(error);\n//     res.status(500).json({ message: 'Error sending verification email' });\n//   }\n// });\n\nmodule.exports = router;","map":{"version":3,"names":["express","require","Joi","bcrypt","multer","sharp","fs","path","gravatar","User","auth","config","sgMail","setApiKey","process","env","SENDGRID_API_KEY","console","log","router","Router","userSchema","object","email","string","required","password","min","storage","diskStorage","destination","req","file","cb","uploadPath","join","__dirname","existsSync","mkdirSync","recursive","filename","uniqueName","Date","now","originalname","upload","v4","uuidv4","post","res","error","validate","body","status","json","message","details","existingUser","findOne","verificationToken","user","avatarURL","url","s","r","d","save","token","generateAuthToken","msg","from","to","subject","text","html","send","then","catch","response","subscription","verify","isMatch","compare","get","module","exports"],"sources":["C:/Users/rebec/Desktop/SlimMom/src/routes/routes.jsx"],"sourcesContent":["const express = require('express');\r\nconst Joi = require('joi');\r\nconst bcrypt = require('bcryptjs');\r\nconst multer = require('multer');\r\nconst sharp = require('sharp'); // Importăm Sharp\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst gravatar = require('gravatar');\r\nconst User = require('../models/Users');\r\nconst auth = require('../middleware/auth');\r\nrequire('dotenv').config();\r\nconst sgMail = require('@sendgrid/mail');\r\n\r\nsgMail.setApiKey(process.env.SENDGRID_API_KEY);\r\nconsole.log(process.env.SENDGRID_API_KEY);  \r\n\r\nconst router = express.Router();\r\n\r\nconst userSchema = Joi.object({\r\n  email: Joi.string().email().required(),\r\n  password: Joi.string().min(6).required(),\r\n});\r\n\r\n// Configurare pentru stocare pe disc\r\nconst storage = multer.diskStorage({\r\n  destination: (req, file, cb) => {\r\n    const uploadPath = path.join(__dirname, '..', 'tmp');\r\n    if (!fs.existsSync(uploadPath)) {\r\n      fs.mkdirSync(uploadPath, { recursive: true });\r\n    }\r\n    cb(null, uploadPath);\r\n  },\r\n  filename: (req, file, cb) => {\r\n    const uniqueName = `${Date.now()}-${file.originalname}`;\r\n    cb(null, uniqueName);\r\n  }\r\n});\r\n\r\nconst upload = multer({ storage: storage });\r\n\r\n// Endpoint pentru înregistrare utilizator\r\n// router.post('/signup', async (req, res) => {\r\n//   const { error } = userSchema.validate(req.body);\r\n//   if (error) return res.status(400).json({ message: error.details[0].message });\r\n\r\n//   const { email, password } = req.body;\r\n//   const existingUser = await User.findOne({ email });\r\n//   if (existingUser) return res.status(409).json({ message: 'Email in use' });\r\n\r\n//   const user = new User({ email, password });\r\n\r\n//   // Generăm avatar cu Gravatar\r\n//   const avatarURL = gravatar.url(user.email, { s: '250', r: 'x', d: 'identicon' });\r\n//   user.avatarURL = avatarURL;\r\n\r\n//   try {\r\n//     await user.save();\r\n//     const token = user.generateAuthToken();\r\n//     user.token = token; \r\n//     await user.save();\r\n\r\n//     res.status(201).json({\r\n//       user: {\r\n//         email: user.email,\r\n//         subscription: user.subscription,\r\n//         avatarURL: user.avatarURL,\r\n//       },\r\n//       token,\r\n//     });\r\n//   } catch (error) {\r\n//     return res.status(500).json({ message: 'Error saving user with token', error });\r\n//   }\r\n// });\r\nconst { v4: uuidv4 } = require('uuid'); // Importăm uuid pentru a genera un token aleator\r\n\r\nrouter.post('/signup', async (req, res) => {\r\n  const { error } = userSchema.validate(req.body);\r\n  if (error) return res.status(400).json({ message: error.details[0].message });\r\n\r\n  const { email, password } = req.body;\r\n  const existingUser = await User.findOne({ email });\r\n  if (existingUser) return res.status(409).json({ message: 'Email in use' });\r\n\r\n  const verificationToken = uuidv4(); // Generăm un token unic de verificare pentru utilizator\r\n\r\n  const user = new User({\r\n    email,\r\n    password,\r\n    verificationToken, // Setăm token-ul de verificare\r\n  });\r\n\r\n  // Generăm avatar cu Gravatar\r\n  const avatarURL = gravatar.url(user.email, { s: '250', r: 'x', d: 'identicon' });\r\n  user.avatarURL = avatarURL;\r\n\r\n  try {\r\n    await user.save();\r\n    const token = user.generateAuthToken();\r\n    user.token = token; \r\n    await user.save();\r\n\r\n    // Trimite e-mail de verificare\r\n    const msg = {\r\n      from: 'rebecavoicilas@yahoo.com', // Asigură-te că folosești o adresă validă\r\n      to: user.email,\r\n      subject: 'Please verify your email address',\r\n      text: `To verify your email address, click on the link below:\\n\\nhttp://localhost:3000/users/verify/${verificationToken}`,\r\n      html: `<p>To verify your email address, click on the link below:</p><a href=\"http://localhost:3000/users/verify/${verificationToken}\">Verify Email</a>`,\r\n    };\r\n\r\n  \r\n    sgMail\r\n    .send(msg)\r\n    .then(() => {\r\n      console.log('Email sent');\r\n    })\r\n    .catch((error) => {\r\n      console.error('Error sending email:', error.response ? error.response.body : error);\r\n    });\r\n  \r\n\r\n    res.status(201).json({\r\n      user: {\r\n        email: user.email,\r\n        subscription: user.subscription,\r\n        avatarURL: user.avatarURL,\r\n      },\r\n      token,\r\n      verificationToken: user.verificationToken,\r\n    });\r\n  } catch (error) {\r\n    return res.status(500).json({ message: 'Error saving user with token', error });\r\n  }\r\n});\r\n\r\n\r\n// Endpoint pentru login utilizator\r\nrouter.post('/login', async (req, res) => {\r\n  const { email, password } = req.body;\r\n\r\n  const { error } = userSchema.validate(req.body);\r\n  if (error) return res.status(400).json({ message: error.details[0].message });\r\n\r\n  const user = await User.findOne({ email });\r\n  if (!user) return res.status(401).json({ message: 'Email or password is wrong' });\r\n\r\n    // Verifică dacă utilizatorul este verificat\r\n  if (!user.verify) {\r\n    return res.status(400).json({ message: 'Email is not verified' });\r\n  }\r\n\r\n  const isMatch = await bcrypt.compare(password, user.password);\r\n  if (!isMatch) return res.status(401).json({ message: 'Email or password is wrong' });\r\n\r\n  const token = user.generateAuthToken();\r\n  user.token = token;\r\n\r\n  try {\r\n    await user.save();\r\n  } catch (error) {\r\n    return res.status(500).json({ message: 'Error saving user with token', error });\r\n  }\r\n\r\n  res.status(200).json({\r\n    token,\r\n    user: {\r\n      email: user.email,\r\n      subscription: user.subscription,\r\n    },\r\n  });\r\n});\r\n\r\n// Endpoint pentru logout utilizator\r\nrouter.get('/logout', auth, async (req, res) => {\r\n  req.user.token = null;\r\n  await req.user.save();\r\n  res.status(204).send();\r\n});\r\n\r\n// // Endpoint pentru obținerea datelor utilizatorului curent\r\n// router.get('/current', auth, (req, res) => {\r\n//   res.status(200).json({\r\n//     email: req.user.email,\r\n//     subscription: req.user.subscription,\r\n//   });\r\n// });\r\n\r\n// // Endpoint pentru actualizarea avatarului\r\n// router.patch('/avatars', auth, upload.single('avatar'), async (req, res) => {\r\n//   try {\r\n//     const userId = req.user.id; // ID-ul utilizatorului este disponibil în req.user datorită middleware-ului auth\r\n//     const user = await User.findById(userId); // Căutăm utilizatorul în baza de date\r\n\r\n//     if (!req.file) {\r\n//       return res.status(400).json({ message: 'No file uploaded' });\r\n//     }\r\n\r\n//     if (!user) {\r\n//       return res.status(404).json({ message: 'User not found' });\r\n//     }\r\n\r\n//     // Calea fișierului temporar și calea finală\r\n//     const tempImagePath = path.join(__dirname, '..', 'tmp', req.file.filename);\r\n//     const avatarName = `${userId}-${Date.now()}.jpg`;\r\n//     const finalAvatarPath = path.join(__dirname, '..', 'public', 'avatars', avatarName);\r\n\r\n//     // Log pentru a verifica calea finală\r\n//     console.log('Temp Image Path:', tempImagePath);\r\n//     console.log('Final Avatar Path:', finalAvatarPath);\r\n\r\n//     // Verificăm dacă directorul 'avatars' există, dacă nu, îl creăm\r\n//     const avatarDir = path.dirname(finalAvatarPath);\r\n//     if (!fs.existsSync(avatarDir)) {\r\n//       fs.mkdirSync(avatarDir, { recursive: true });\r\n//       console.log('Created avatars directory:', avatarDir);  // Log pentru a confirma crearea directorului\r\n//     }\r\n\r\n//     // Folosim sharp pentru a redimensiona imaginea\r\n//     await sharp(tempImagePath)\r\n//       .resize(250, 250)\r\n//       .toFile(finalAvatarPath);  // Scriem fișierul procesat în folderul public/avatars\r\n\r\n//     // Actualizăm avatarURL-ul în baza de date\r\n//     user.avatarURL = `/avatars/${avatarName}`;\r\n//     await user.save(); // Salvăm utilizatorul cu noul avatar\r\n\r\n//     // Răspuns de succes cu URL-ul avatarului\r\n//     res.status(200).json({ avatarURL: user.avatarURL });\r\n\r\n//   } catch (error) {\r\n//     console.error(error);\r\n//     res.status(500).json({ message: 'Internal server error' });\r\n//     console.log('Request file:', req.file);\r\n//     console.log('Request body:', req.body);\r\n//     console.log('Request headers:', req.headers);\r\n//   }\r\n// });\r\n\r\n// router.get('/verify/:verificationToken', async (req, res) => {\r\n//   const { verificationToken } = req.params; // Extragem tokenul de verificare din URL\r\n//   console.log('Verification Token:', verificationToken);\r\n\r\n//   // Căutăm utilizatorul în baza de date care are acest token de verificare\r\n//   const user = await User.findOne({ verificationToken }); \r\n\r\n//   if (!user) {\r\n//     return res.status(404).json({ message: 'User not found' }); // Dacă nu găsim utilizatorul cu tokenul respectiv\r\n//   }\r\n\r\n//   if (user.verify) {\r\n//     return res.status(400).json({ message: 'Email is already verified' }); // Dacă utilizatorul a fost deja verificat\r\n//   }\r\n\r\n//   // Dacă utilizatorul a fost găsit și nu a fost încă verificat\r\n//   user.verify = true; // Setăm câmpul `verify` la `true` pentru a indica faptul că emailul a fost verificat\r\n//   user.verificationToken = null; // Ștergem tokenul de verificare, deoarece a fost utilizat\r\n//   await user.save(); // Salvăm modificările în baza de date\r\n//   console.log('User after verification:', user);\r\n\r\n\r\n//   res.status(200).json({ message: 'Verification successful' }); // Răspuns de succes\r\n// });\r\n\r\n\r\n// // Endpoint pentru trimiterea unui e-mail de verificare repetat\r\n// router.post('/verify', async (req, res) => {\r\n//   const { email } = req.body; // Extragem email-ul din request body\r\n  \r\n\r\n//   if (!email) {\r\n//     return res.status(400).json({ message: 'missing required field email' }); // Verificăm dacă există câmpul email\r\n//   }\r\n\r\n//   const user = await User.findOne({ email }); // Căutăm utilizatorul cu acest email\r\n//   console.log('User found:', user);\r\n\r\n\r\n//   if (!user) {\r\n//     return res.status(404).json({ message: 'User not found' }); // Dacă utilizatorul nu există\r\n//   }\r\n\r\n//   if (user.verify) {\r\n//     return res.status(400).json({ message: 'Verification has already been passed' }); // Dacă utilizatorul este deja verificat\r\n//   }\r\n\r\n//   // Trimitem e-mail de verificare\r\n//   const msg = {\r\n//     to: user.email,\r\n//     from: 'rebecavoicilas@yahoo.com', // Adresa de e-mail de pe care se trimit mesajele\r\n//     subject: 'Please verify your email address',\r\n//     text: `To verify your email address, click on the link below:\\n\\nhttp://localhost:3000/users/verify/${user.verificationToken}`,\r\n//     html: `<p>To verify your email address, click on the link below:</p><a href=\"http://localhost:3000/users/verify/${user.verificationToken}\">Verify Email</a>`,\r\n//   };\r\n\r\n//   try {\r\n//     await sgMail.send(msg); // Trimiterea efectivă a e-mailului\r\n//     res.status(200).json({ message: 'Verification email sent' });\r\n//   } catch (error) {\r\n//     console.error(error);\r\n//     res.status(500).json({ message: 'Error sending verification email' });\r\n//   }\r\n// });\r\n\r\nmodule.exports = router;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}